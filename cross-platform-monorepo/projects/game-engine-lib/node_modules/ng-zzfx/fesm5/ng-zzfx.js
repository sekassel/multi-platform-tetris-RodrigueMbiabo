import { __spread, __decorate } from 'tslib';
import { ElementRef, Renderer2, Input, Directive, NgModule } from '@angular/core';

// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX
// This is a tiny build of zzfx with only a zzfx function to play sounds.
// You can use zzfxV to set volume.
// There is a small bit of optional code to improve compatibility.
// Feel free to minify it further for your own needs!
// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX
'use strict';
var zzfx;
var zzfxV;
var zzfxX;
// Liron's wrapping in order to expose API:
function ZZFX(vol) {
    // ZzFXMicro - Zuper Zmall Zound Zynth
    zzfxV = vol; // volume
    zzfx = // play sound
        function (J, K, h, f, k, n, g, A, r, B, t, C, u, D, v, L, e, c, b, w, x, M, E, N, q, F, G, d, l, H, I, a, O, m, y, z) {
            if (J === void 0) { J = 1; }
            if (K === void 0) { K = .05; }
            if (h === void 0) { h = 220; }
            if (f === void 0) { f = 0; }
            if (k === void 0) { k = 0; }
            if (n === void 0) { n = .1; }
            if (g === void 0) { g = 0; }
            if (A === void 0) { A = 1; }
            if (r === void 0) { r = 0; }
            if (B === void 0) { B = 0; }
            if (t === void 0) { t = 0; }
            if (C === void 0) { C = 0; }
            if (u === void 0) { u = 0; }
            if (D === void 0) { D = 0; }
            if (v === void 0) { v = 0; }
            if (L === void 0) { L = 0; }
            if (e === void 0) { e = 0; }
            if (c === void 0) { c = 2 * Math.PI; }
            if (b === void 0) { b = 44100; }
            if (w === void 0) { w = function (p) { return 2 * p * Math.random() - p; }; }
            if (x === void 0) { x = function (p) { return 0 < p ? 1 : -1; }; }
            if (M === void 0) { M = r *= 500 * c / Math.pow(b, 2); }
            if (E === void 0) { E = h *= (1 + w(K)) * c / b; }
            if (N === void 0) { N = x(v) * c / 4; }
            if (q === void 0) { q = []; }
            if (F === void 0) { F = 0; }
            if (G === void 0) { G = 0; }
            if (d === void 0) { d = 0; }
            if (l === void 0) { l = 1; }
            if (H === void 0) { H = 0; }
            if (I === void 0) { I = 0; }
            if (a === void 0) { a = 0; }
            if (O === void 0) { O = .5; }
            if (z === void 0) { z = zzfxX.createBufferSource(); }
            f = 50 + f * b | 0;
            k = k * b | 0;
            n = n * b | 0;
            e = e * b | 0;
            B *= 500 * c / Math.pow(b, 3);
            m = f + k + n + e;
            v *= c / b;
            t *= c / b;
            C *= b;
            for (u *= b; d < m; q[d++] = a)
                ++I > 100 * L && (I = 0, a = F * h * Math.sin(G * v - N), a = g ? 1 < g ? 2 < g ? 3 < g ? 4 < g ? x((a / c % 1 + 1) % 1 - (O += 1e3 * A / b) % 1) : Math.sin(Math.pow((a % c), 3)) : Math.max(Math.min(Math.tan(a), 1), -1) : 1 - (2 * a / c % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(a / c) - a / c) : Math.sin(a), 5 > g && (a = x(a) * Math.pow(Math.abs(a), A)), a *= J * zzfxV * (d < f ? d / f : d < f + k ? 1 : d < m - e ? 1 - (d - f - k) / n : 0), a = e ? a / 2 + (e > d ? 0 : (d < m - e ? 1 : (d - m) / e) * q[d - e] / 2) : a), F += 1 + w(D), G += 1 + w(D), h += r += B, l && ++l > C && (E += t, h += t, l = 0), u && ++H > u && (h = E, r = M, H = 1, l = l || 1);
            y = zzfxX.createBuffer(1, q.length, b);
            y.getChannelData(0).set(q);
            z.buffer = y;
            z.connect(zzfxX.destination);
            z.start();
        };
    zzfxX = new (window.AudioContext || webkitAudioContext);
    zzfxX.z = zzfxX.createBufferSource;
    zzfxX.createBufferSource = function (s) {
        if (s === void 0) { s = zzfxX.z(); }
        return (s.start = s.start || (function (t) { return zzfxX.noteOn(t); }), s);
    };
    return zzfx;
}

var Zoundfx = /** @class */ (function () {
    function Zoundfx() {
    }
    Zoundfx.start = function (vol) {
        var zzfxFn = ZZFX(vol);
        return function (sound) {
            zzfxFn.apply(void 0, __spread(sound));
        };
    };
    return Zoundfx;
}());

var ZoundfxDirective = /** @class */ (function () {
    function ZoundfxDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.vol = 0.1; // Number from 0 to 1;
        this.trigger = 'onclick';
    }
    ZoundfxDirective.prototype.ngAfterViewInit = function () {
        this.zzfxFn = ZZFX(this.vol);
        this.registerEventListeners();
    };
    ZoundfxDirective.prototype.registerEventListeners = function () {
        var _this = this;
        this.renderer.listen(this.el.nativeElement, this.trigger, function () {
            _this.zzfxFn.apply(_this, __spread(_this.zound));
        });
    };
    ZoundfxDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input()
    ], ZoundfxDirective.prototype, "vol", void 0);
    __decorate([
        Input()
    ], ZoundfxDirective.prototype, "trigger", void 0);
    __decorate([
        Input()
    ], ZoundfxDirective.prototype, "zound", void 0);
    ZoundfxDirective = __decorate([
        Directive({
            selector: '[zoundfx]'
        })
    ], ZoundfxDirective);
    return ZoundfxDirective;
}());

var NgZzfxModule = /** @class */ (function () {
    function NgZzfxModule() {
    }
    NgZzfxModule = __decorate([
        NgModule({
            declarations: [ZoundfxDirective],
            exports: [ZoundfxDirective]
        })
    ], NgZzfxModule);
    return NgZzfxModule;
}());

/*
 * Public API Surface of ng-zzfx
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgZzfxModule, Zoundfx, ZoundfxDirective };
//# sourceMappingURL=ng-zzfx.js.map
