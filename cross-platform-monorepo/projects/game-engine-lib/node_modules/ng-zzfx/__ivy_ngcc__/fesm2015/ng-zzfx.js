import { __decorate } from 'tslib';
import { ElementRef, Renderer2, Input, Directive, NgModule } from '@angular/core';

// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX
// This is a tiny build of zzfx with only a zzfx function to play sounds.
// You can use zzfxV to set volume.
// There is a small bit of optional code to improve compatibility.
// Feel free to minify it further for your own needs!
// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX
import * as ɵngcc0 from '@angular/core';
'use strict';
let zzfx;
let zzfxV;
let zzfxX;
// Liron's wrapping in order to expose API:
function ZZFX(vol) {
    // ZzFXMicro - Zuper Zmall Zound Zynth
    zzfxV = vol; // volume
    zzfx = // play sound
        (J = 1, K = .05, h = 220, f = 0, k = 0, n = .1, g = 0, A = 1, r = 0, B = 0, t = 0, C = 0, u = 0, D = 0, v = 0, L = 0, e = 0, c = 2 * Math.PI, b = 44100, w = p => 2 * p * Math.random() - p, x = p => 0 < p ? 1 : -1, M = r *= 500 * c / Math.pow(b, 2), E = h *= (1 + w(K)) * c / b, N = x(v) * c / 4, q = [], F = 0, G = 0, d = 0, l = 1, H = 0, I = 0, a = 0, O = .5, m, y, z = zzfxX.createBufferSource()) => { f = 50 + f * b | 0; k = k * b | 0; n = n * b | 0; e = e * b | 0; B *= 500 * c / Math.pow(b, 3); m = f + k + n + e; v *= c / b; t *= c / b; C *= b; for (u *= b; d < m; q[d++] = a)
            ++I > 100 * L && (I = 0, a = F * h * Math.sin(G * v - N), a = g ? 1 < g ? 2 < g ? 3 < g ? 4 < g ? x((a / c % 1 + 1) % 1 - (O += 1e3 * A / b) % 1) : Math.sin(Math.pow((a % c), 3)) : Math.max(Math.min(Math.tan(a), 1), -1) : 1 - (2 * a / c % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(a / c) - a / c) : Math.sin(a), 5 > g && (a = x(a) * Math.pow(Math.abs(a), A)), a *= J * zzfxV * (d < f ? d / f : d < f + k ? 1 : d < m - e ? 1 - (d - f - k) / n : 0), a = e ? a / 2 + (e > d ? 0 : (d < m - e ? 1 : (d - m) / e) * q[d - e] / 2) : a), F += 1 + w(D), G += 1 + w(D), h += r += B, l && ++l > C && (E += t, h += t, l = 0), u && ++H > u && (h = E, r = M, H = 1, l = l || 1); y = zzfxX.createBuffer(1, q.length, b); y.getChannelData(0).set(q); z.buffer = y; z.connect(zzfxX.destination); z.start(); };
    zzfxX = new (window.AudioContext || webkitAudioContext);
    zzfxX.z = zzfxX.createBufferSource;
    zzfxX.createBufferSource = (s = zzfxX.z()) => (s.start = s.start || (t => zzfxX.noteOn(t)), s);
    return zzfx;
}

class Zoundfx {
    static start(vol) {
        const zzfxFn = ZZFX(vol);
        return (sound) => {
            zzfxFn(...sound);
        };
    }
}

let ZoundfxDirective = class ZoundfxDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.vol = 0.1; // Number from 0 to 1;
        this.trigger = 'onclick';
    }
    ngAfterViewInit() {
        this.zzfxFn = ZZFX(this.vol);
        this.registerEventListeners();
    }
    registerEventListeners() {
        this.renderer.listen(this.el.nativeElement, this.trigger, () => {
            this.zzfxFn(...this.zound);
        });
    }
};
ZoundfxDirective.ɵfac = function ZoundfxDirective_Factory(t) { return new (t || ZoundfxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ZoundfxDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ZoundfxDirective, selectors: [["", "zoundfx", ""]], inputs: { vol: "vol", trigger: "trigger", zound: "zound" } });
ZoundfxDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input()
], ZoundfxDirective.prototype, "vol", void 0);
__decorate([
    Input()
], ZoundfxDirective.prototype, "trigger", void 0);
__decorate([
    Input()
], ZoundfxDirective.prototype, "zound", void 0);

let NgZzfxModule = class NgZzfxModule {
};
NgZzfxModule.ɵfac = function NgZzfxModule_Factory(t) { return new (t || NgZzfxModule)(); };
NgZzfxModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgZzfxModule });
NgZzfxModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ZoundfxDirective, [{
        type: Directive,
        args: [{
                selector: '[zoundfx]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { vol: [{
            type: Input
        }], trigger: [{
            type: Input
        }], zound: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgZzfxModule, [{
        type: NgModule,
        args: [{
                declarations: [ZoundfxDirective],
                exports: [ZoundfxDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgZzfxModule, { declarations: [ZoundfxDirective], exports: [ZoundfxDirective] }); })();

/*
 * Public API Surface of ng-zzfx
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgZzfxModule, Zoundfx, ZoundfxDirective };

//# sourceMappingURL=ng-zzfx.js.map